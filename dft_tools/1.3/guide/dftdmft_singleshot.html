<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Single-shot DFT+DMFT &mdash; TRIQS_DFT Tools  documentation</title>
    
    <link rel="stylesheet" href="../_static/triqs.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/MathJax/MathJax.js?config=default"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="TRIQS_DFT Tools  documentation" href="../contents.html" />
    <link rel="up" title="Documentation" href="../documentation.html" />
    <link rel="next" title="Full charge self consistency" href="dftdmft_selfcons.html" />
    <link rel="prev" title="Orbital construction and conversion" href="conversion.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    
    <li><a href="../install.html">Install</a></li>
    
    <li><a href="../documentation.html">Documentation</a></li>
    
    <li><a href="../issues.html">Issues</a></li>
    
    <li><a href="../about.html">About dft_tools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../index.html">dft_tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://ipht.cea.fr/triqs">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dftdmft_selfcons.html" title="Full charge self consistency"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="Orbital construction and conversion"
             accesskey="P">previous</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" accesskey="U">Documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Single-shot DFT+DMFT</a><ul>
<li><a class="reference internal" href="#initialisation-of-the-calculation">Initialisation of the calculation</a></li>
<li><a class="reference internal" href="#setting-up-the-impurity-solver">Setting up the impurity solver</a></li>
<li><a class="reference internal" href="#doing-the-dmft-loop">Doing the DMFT loop</a></li>
<li><a class="reference internal" href="#a-full-dft-dmft-calculation">A full DFT+DMFT calculation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="conversion.html"
                        title="previous chapter">Orbital construction and conversion</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dftdmft_selfcons.html"
                        title="next chapter">Full charge self consistency</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/dftdmft_singleshot.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="single-shot-dft-dmft">
<span id="singleshot"></span><h1>Single-shot DFT+DMFT<a class="headerlink" href="#single-shot-dft-dmft" title="Permalink to this headline">¶</a></h1>
<p>After having set up the hdf5 archive, we can now do our DFT+DMFT calculation. It consists of
initialization steps, and the actual DMFT self-consistency loop, as is
discussed below.</p>
<div class="section" id="initialisation-of-the-calculation">
<h2>Initialisation of the calculation<a class="headerlink" href="#initialisation-of-the-calculation" title="Permalink to this headline">¶</a></h2>
<p>Before doing the calculation, we have to intialize all the objects that we will need. The first thing is the
<a class="reference internal" href="../reference/sumk_dft.html#pytriqs.applications.dft.sumk_dft.SumkDFT" title="pytriqs.applications.dft.sumk_dft.SumkDFT"><code class="xref py py-class docutils literal"><span class="pre">SumkDFT</span></code></a> class. It contains all basic routines that are necessary to perform a summation in k-space
to get the local quantities used in DMFT. It is initialized by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pytriqs.applications.dft.sumk_dft</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">SK</span> <span class="o">=</span> <span class="n">SumkDFT</span><span class="p">(</span><span class="n">hdf_file</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;.h5&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-the-impurity-solver">
<h2>Setting up the impurity solver<a class="headerlink" href="#setting-up-the-impurity-solver" title="Permalink to this headline">¶</a></h2>
<p>The next step is to setup an impurity solver. There are different
solvers available within the <a class="reference external" href="http://ipht.cea.fr/triqs/index.html#welcome" title="(in TRIQS v1.0)"><span class="xref std std-ref">TRIQS</span></a> framework. Below, we will discuss
the example of the hybridisation
expansion <a class="reference external" href="http://ipht.cea.fr/triqs/applications/cthyb/index.html#welcome" title="(in TRIQS Hybridization Expansion Solver v1.3)"><span class="xref std std-ref">CTHYB solver</span></a>. Later on, we will
see also the example of the Hubbard-I solver. They all have in common,
that they are called by a uniform command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>params</cite> are the solver parameters and depend on the actual
solver that is used. Before going into the details of the solver, let
us discuss in the next section how to perform the DMFT loop using
the methods of <strong class="program">dft_tools</strong>, assuming that we have set up a
working solver instance.</p>
</div>
<div class="section" id="doing-the-dmft-loop">
<h2>Doing the DMFT loop<a class="headerlink" href="#doing-the-dmft-loop" title="Permalink to this headline">¶</a></h2>
<p>Having initialized the SumK class and the Solver, we can proceed with the DMFT
loop itself. We have to set up the loop over DMFT
iterations and the self-consistency condition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n_loops</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">for</span> <span class="n">iteration_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_loops</span><span class="p">)</span> <span class="p">:</span>            <span class="c"># start the DMFT loop</span>

        <span class="n">SK</span><span class="o">.</span><span class="n">put_Sigma</span><span class="p">(</span><span class="n">Sigma_imp</span> <span class="o">=</span> <span class="p">[</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma</span> <span class="p">])</span>              <span class="c"># Put self energy to the SumK class</span>
        <span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">calc_mu</span><span class="p">()</span>                  <span class="c"># calculate the chemical potential for the given density</span>
        <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">SK</span><span class="o">.</span><span class="n">extract_G_loc</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>                    <span class="c"># extract the local Green function</span>
        <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span> <span class="o">&lt;&lt;</span> <span class="n">inverse</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">+</span> <span class="n">inverse</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="p">))</span>   <span class="c"># finally get G0, the input for the Solver</span>

        <span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">h_int</span><span class="o">=</span><span class="n">h_int</span><span class="p">,</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>                          <span class="c"># now solve the impurity problem</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>                                                 <span class="c"># Density matrix of the impurity problem</span>
        <span class="n">SK</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">U_interact</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_formula</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Set the double counting term</span>
        <span class="n">SK</span><span class="o">.</span><span class="n">save</span><span class="p">([</span><span class="s">&#39;chemical_potential&#39;</span><span class="p">,</span><span class="s">&#39;dc_imp&#39;</span><span class="p">,</span><span class="s">&#39;dc_energ&#39;</span><span class="p">])</span>                   <span class="c"># Save data in the hdf5 archive</span>
</pre></div>
</div>
<p>These basic steps are enough to set up the basic DMFT Loop. For a detailed
description of the <a class="reference internal" href="../reference/sumk_dft.html#pytriqs.applications.dft.sumk_dft.SumkDFT" title="pytriqs.applications.dft.sumk_dft.SumkDFT"><code class="xref py py-class docutils literal"><span class="pre">SumkDFT</span></code></a> routines, see the reference
manual.</p>
<p>After
the self-consistency steps (extracting a new <span class="math">\(G^0(i\omega)\)</span>),
the Anderson impurity problem is solved.</p>
<p>Different to model calculations, we have to do a few
more steps after this, because of the double-counting correction. We first
calculate the density of the impurity problem. Then, the routine <cite>calc_dc</cite>
takes as parameters this density matrix, the Coulomb interaction, Hund&#8217;s rule
coupling, and the type of double-counting that should be used. Possible values
for <cite>use_dc_formula</cite> are:</p>
<blockquote>
<div><ul class="simple">
<li><cite>0</cite>: Full-localised limit</li>
<li><cite>1</cite>: DC formula as given in K. Held, Adv. Phys. 56, 829 (2007).</li>
<li><cite>2</cite>: Around-mean-field</li>
</ul>
</div></blockquote>
<p>At the end of the calculation, we can save the Greens function and self energy into a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="kn">import</span> <span class="n">HDFArchive</span>
<span class="kn">import</span> <span class="nn">pytriqs.utility.mpi</span> <span class="kn">as</span> <span class="nn">mpi</span>
<span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="s">&quot;YourDFTDMFTcalculation.h5&quot;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">ar</span><span class="p">[</span><span class="s">&quot;G&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span>
    <span class="n">ar</span><span class="p">[</span><span class="s">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span>
</pre></div>
</div>
<p>This is it!</p>
<p>These are the essential steps to do a one-shot DFT+DMFT calculation.
For full charge-self consistent calculations, there are some more things
to consider, which we will see later on.</p>
</div>
<div class="section" id="a-full-dft-dmft-calculation">
<h2>A full DFT+DMFT calculation<a class="headerlink" href="#a-full-dft-dmft-calculation" title="Permalink to this headline">¶</a></h2>
<p>We will discuss now how to set up a full working calculation,
including setting up the CTHYB solver, and specifying some more parameters
in order to make the calculation more efficient. Here, we
will see a more advanced example, which is also suited for parallel
execution. For the convenience of the user, we provide also two
working python scripts in this documentation. One for a calculation
using Kanamori definitions (<a class="reference download internal" href="../_downloads/dft_dmft_cthyb.py"><code class="xref download docutils literal"><span class="pre">dft_dmft_cthyb.py</span></code></a>) and one with a
rotational-invariant Slater interaction hamiltonian (<a class="reference download internal" href="../_downloads/dft_dmft_cthyb.py"><code class="xref download docutils literal"><span class="pre">dft_dmft_cthyb_slater.py</span></code></a>). The user has to adapt these
scripts to his own needs.</p>
<p>First, we load the necessary modules:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pytriqs.applications.dft.sumk_dft</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.gf.local</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="kn">import</span> <span class="n">HDFArchive</span>
<span class="kn">from</span> <span class="nn">pytriqs.operators.util</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.applications.impurity_solvers.cthyb</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>The last two lines load the modules for the construction of the CTHYB
solver.</p>
<p>Then we define some parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dft_filename</span><span class="o">=</span><span class="s">&#39;SrVO3&#39;</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="n">J</span> <span class="o">=</span> <span class="mf">0.65</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">loops</span> <span class="o">=</span>  <span class="mi">10</span>                      <span class="c"># Number of DMFT sc-loops</span>
<span class="n">sigma_mix</span> <span class="o">=</span> <span class="mf">0.8</span>                  <span class="c"># Mixing factor of Sigma after solution of the AIM</span>
<span class="n">dc_type</span> <span class="o">=</span> <span class="mi">1</span>                      <span class="c"># DC type: 0 FLL, 1 Held, 2 AMF</span>
<span class="n">use_blocks</span> <span class="o">=</span> <span class="bp">True</span>                <span class="c"># use bloc structure from DFT input</span>
<span class="n">prec_mu</span> <span class="o">=</span> <span class="mf">0.0001</span>

<span class="c"># Solver parameters</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">p</span><span class="p">[</span><span class="s">&quot;length_cycle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">p</span><span class="p">[</span><span class="s">&quot;n_warmup_cycles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">p</span><span class="p">[</span><span class="s">&quot;n_cycles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20000</span>
</pre></div>
</div>
<p>Most of these parameters are self-explanatory. The first,
<cite>dft_filename</cite>, gives the filename of the input files. For more
details on the solver parameters, we refer the user to
the <a class="reference external" href="http://ipht.cea.fr/triqs/applications/cthyb/index.html#welcome" title="(in TRIQS Hybridization Expansion Solver v1.3)"><span class="xref std std-ref">CTHYB solver</span></a> documentation.</p>
<p>We assume that the conversion to the hdf5 archive is alreadz done. We
can check now in this archive, if previous runs are present, or if we have to start
from scratch:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">previous_runs</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">previous_present</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&#39;dmft_output&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;iterations&#39;</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
            <span class="n">previous_present</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">previous_runs</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s">&#39;iterations&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s">&#39;dmft_output&#39;</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">f</span>
<span class="n">previous_runs</span>    <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">previous_runs</span><span class="p">)</span>
<span class="n">previous_present</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">previous_present</span><span class="p">)</span>
</pre></div>
</div>
<p>You can see in this code snipet, that all results of this calculation
will be stored in a separate subgroup in the hdf5 file, called
<cite>dmft_output</cite>. Removing this subgroup allows you to reset your
calculation to the starting point easily.</p>
<p>Now we can use all this information to initialise the <a class="reference internal" href="../reference/sumk_dft.html#pytriqs.applications.dft.sumk_dft.SumkDFT" title="pytriqs.applications.dft.sumk_dft.SumkDFT"><code class="xref py py-class docutils literal"><span class="pre">SumkDFT</span></code></a> class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SK</span> <span class="o">=</span> <span class="n">SumkDFT</span><span class="p">(</span><span class="n">hdf_file</span><span class="o">=</span><span class="n">dft_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">use_dft_blocks</span><span class="o">=</span><span class="n">use_blocks</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to initialise the  <a class="reference external" href="http://ipht.cea.fr/triqs/applications/cthyb/reference/solver.html#pytriqs.applications.impurity_solvers.cthyb.Solver" title="(in TRIQS Hybridization Expansion Solver v1.3)"><code class="xref py py-class docutils literal"><span class="pre">Solver</span></code></a> class. It consist
of two steps</p>
<ol class="arabic simple">
<li>Calculating the multi-band interaction matrix, and setting up the
interaction hamiltonian</li>
<li>Setting up the solver class</li>
</ol>
<p>The first step is done using methods of
the <a class="reference external" href="http://ipht.cea.fr/triqs/index.html#welcome" title="(in TRIQS v1.0)"><span class="xref std std-ref">TRIQS</span></a> library:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n_orb</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;l&#39;</span><span class="p">]</span>
<span class="n">spin_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;up&quot;</span><span class="p">,</span><span class="s">&quot;down&quot;</span><span class="p">]</span>
<span class="n">orb_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
<span class="c"># Use GF structure determined by DFT blocks:</span>
<span class="n">gf_struct</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># Construct U matrix for density-density calculations:</span>
<span class="n">Umat</span><span class="p">,</span> <span class="n">Upmat</span> <span class="o">=</span> <span class="n">U_matrix_kanamori</span><span class="p">(</span><span class="n">n_orb</span><span class="o">=</span><span class="n">n_orb</span><span class="p">,</span> <span class="n">U_int</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span><span class="o">=</span><span class="n">J</span><span class="p">)</span>
</pre></div>
</div>
<p>We assumed here that we want to use an interaction matrix with
Kanamori definitions of <span class="math">\(U\)</span> and <span class="math">\(J\)</span>. For
other choices (Slater interaction matrix for instance), and other
parameters, we refer to the reference manual
of the <a class="reference external" href="http://ipht.cea.fr/triqs/index.html#welcome" title="(in TRIQS v1.0)"><span class="xref std std-ref">TRIQS</span></a> library.</p>
<p>Next, we construct the hamiltonian and the solver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h_int</span> <span class="o">=</span> <span class="n">h_int_density</span><span class="p">(</span><span class="n">spin_names</span><span class="p">,</span> <span class="n">orb_names</span><span class="p">,</span> <span class="n">map_operator_structure</span><span class="o">=</span><span class="n">SK</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">U</span><span class="o">=</span><span class="n">Umat</span><span class="p">,</span> <span class="n">Uprime</span><span class="o">=</span><span class="n">Upmat</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">gf_struct</span><span class="o">=</span><span class="n">gf_struct</span><span class="p">)</span>
</pre></div>
</div>
<p>As you see, we take only density-density interactions into
account. Other choices for the hamiltonian are</p>
<ul class="simple">
<li>h_int_kanamori</li>
<li>h_int_slater</li>
</ul>
<p>These two include full rotational invariant interactions. Again,
options can be found in the <a class="reference external" href="http://ipht.cea.fr/triqs/index.html#welcome" title="(in TRIQS v1.0)"><span class="xref std std-ref">TRIQS</span></a> library
reference manual.</p>
<p>If there are previous runs stored in the hdf5 archive, we can now load the self energy
of the last iteration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">previous_present</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
      <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
      <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;Sigma_iw&#39;</span><span class="p">]</span>
      <span class="k">del</span> <span class="n">ar</span>
      <span class="n">chemical_potential</span><span class="p">,</span><span class="n">dc_imp</span><span class="p">,</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">load</span><span class="p">([</span><span class="s">&#39;chemical_potential&#39;</span><span class="p">,</span><span class="s">&#39;dc_imp&#39;</span><span class="p">,</span><span class="s">&#39;dc_energ&#39;</span><span class="p">])</span>
  <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">)</span>
  <span class="n">SK</span><span class="o">.</span><span class="n">set_mu</span><span class="p">(</span><span class="n">chemical_potential</span><span class="p">)</span>
  <span class="n">SK</span><span class="o">.</span><span class="n">set_dc</span><span class="p">(</span><span class="n">dc_imp</span><span class="p">,</span><span class="n">dc_energ</span><span class="p">)</span>
</pre></div>
</div>
<p>The self-energy is broadcast from the master node to the slave nodes. Also, the
last saved chemical potential and double counting values are read in and set.</p>
<p>Now we can go to the definition of the self-consistency step. It consists again
of the basic steps discussed in the previous section, with some additional
refinements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">iteration_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">loops</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span> <span class="k">print</span> <span class="s">&quot;Iteration = &quot;</span><span class="p">,</span> <span class="n">iteration_number</span>

    <span class="n">SK</span><span class="o">.</span><span class="n">symm_deg_gf</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">,</span><span class="n">orb</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>                        <span class="c"># symmetrise Sigma</span>
    <span class="n">SK</span><span class="o">.</span><span class="n">put_Sigma</span><span class="p">(</span><span class="n">Sigma_imp</span> <span class="o">=</span> <span class="p">[</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="p">])</span>                <span class="c"># put Sigma into the SumK class</span>
    <span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">calc_mu</span><span class="p">(</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">prec_mu</span> <span class="p">)</span>  <span class="c"># find the chemical potential for given density</span>
    <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">SK</span><span class="o">.</span><span class="n">extract_G_loc</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>                         <span class="c"># calc the local Green function</span>
    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;Total charge of Gloc : </span><span class="si">%.6f</span><span class="s">&quot;</span><span class="o">%</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">total_density</span><span class="p">())</span>

    <span class="c"># Init the DC term and the real part of Sigma, if no previous runs found:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">previous_present</span><span class="o">==</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
        <span class="n">SK</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">U_interact</span> <span class="o">=</span> <span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span> <span class="o">=</span> <span class="n">J</span><span class="p">,</span> <span class="n">orb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="n">dc_type</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">SK</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;up&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># Calculate new G0_iw to input into the solver:</span>
    <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">+</span> <span class="n">inverse</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="p">)</span>
    <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span> <span class="o">&lt;&lt;</span> <span class="n">inverse</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span><span class="p">)</span>

    <span class="c"># Solve the impurity problem:</span>
    <span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">h_int</span><span class="o">=</span><span class="n">h_int</span><span class="p">,</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>

    <span class="c"># Solved. Now do post-solution stuff:</span>
    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;Total charge of impurity problem : </span><span class="si">%.6f</span><span class="s">&quot;</span><span class="o">%</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">total_density</span><span class="p">())</span>

    <span class="c"># Now mix Sigma and G with factor sigma_mix, if wanted:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">previous_present</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;Mixing Sigma and G with factor </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="n">sigma_mix</span><span class="p">)</span>
            <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">sigma_mix</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">sigma_mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;Sigma_iw&#39;</span><span class="p">]</span>
            <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">sigma_mix</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">sigma_mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;G_iw&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">ar</span>
        <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">)</span>

    <span class="c"># Write the final Sigma and G to the hdf5 archive:</span>
    <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iteration_number</span> <span class="o">+</span> <span class="n">previous_runs</span>
        <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;G_0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span>
        <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;G_tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_tau</span>
        <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;G_iw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span>
        <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s">&#39;Sigma_iw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span>
        <span class="k">del</span> <span class="n">ar</span>

    <span class="c"># Set the new double counting:</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span> <span class="c"># compute the density matrix of the impurity problem</span>
    <span class="n">SK</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">U_interact</span> <span class="o">=</span> <span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span> <span class="o">=</span> <span class="n">J</span><span class="p">,</span> <span class="n">orb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="n">dc_type</span><span class="p">)</span>

    <span class="c"># Save stuff into the dft_output group of hdf5 archive in case of rerun:</span>
    <span class="n">SK</span><span class="o">.</span><span class="n">save</span><span class="p">([</span><span class="s">&#39;chemical_potential&#39;</span><span class="p">,</span><span class="s">&#39;dc_imp&#39;</span><span class="p">,</span><span class="s">&#39;dc_energ&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This is all we need for the DFT+DMFT calculation. At the end, all results are stored in the hdf5 output file.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dftdmft_selfcons.html" title="Full charge self consistency"
             >next</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="Orbital construction and conversion"
             >previous</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-2013, M. Aichhorn, L. Pourovskii, V. Vildosola, C. Martins.
    </div>
  </body>
</html>
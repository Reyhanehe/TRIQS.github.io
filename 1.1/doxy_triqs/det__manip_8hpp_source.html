<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>/home/parcolle/triqs/src/triqs/triqs/det_manip/det_manip.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/parcolle/triqs/src/triqs/triqs/det_manip/det_manip.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * TRIQS: a Toolbox for Research in Interacting Quantum Systems</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (C) 2011-2013 by M. Ferrero, O. Parcollet</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * TRIQS is free software: you can redistribute it and/or modify it under the</span>
<a name="l00008"></a>00008 <span class="comment"> * terms of the GNU General Public License as published by the Free Software</span>
<a name="l00009"></a>00009 <span class="comment"> * Foundation, either version 3 of the License, or (at your option) any later</span>
<a name="l00010"></a>00010 <span class="comment"> * version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<a name="l00013"></a>00013 <span class="comment"> * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<a name="l00014"></a>00014 <span class="comment"> * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<a name="l00015"></a>00015 <span class="comment"> * details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * You should have received a copy of the GNU General Public License along with</span>
<a name="l00018"></a>00018 <span class="comment"> * TRIQS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> ******************************************************************************/</span>
<a name="l00021"></a>00021 <span class="preprocessor">#ifndef TRIQS_DETMANIP_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#define TRIQS_DETMANIP_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#include &lt;triqs/utility/first_include.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;triqs/arrays.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;triqs/arrays/algorithms.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;triqs/arrays/linalg/det_and_inverse.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;triqs/arrays/blas_lapack/dot.hpp&gt;</span> 
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;triqs/arrays/blas_lapack/ger.hpp&gt;</span> 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;triqs/arrays/blas_lapack/gemm.hpp&gt;</span> 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;triqs/arrays/blas_lapack/gemv.hpp&gt;</span> 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;triqs/utility/function_arg_ret_type.hpp&gt;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>triqs { <span class="keyword">namespace </span>det_manip { 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037  <span class="keyword">namespace </span>blas = arrays::blas;
<a name="l00038"></a>00038 
<a name="l00042"></a>00042  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;
<a name="l00043"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html">00043</a>   <span class="keyword">class </span><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html" title="Standard matrix/det manipulations used in several QMC.">det_manip</a> {
<a name="l00044"></a>00044    <span class="keyword">private</span>:
<a name="l00045"></a>00045     <span class="keyword">typedef</span> utility::function_arg_ret_type&lt;FunctionType&gt; f_tr;
<a name="l00046"></a>00046     static_assert(f_tr::arity == 2, <span class="stringliteral">&quot;det_manip : the function must take two arguments !&quot;</span>);
<a name="l00047"></a>00047     <span class="comment">// Do we REALLY need this ?</span>
<a name="l00048"></a>00048     static_assert(std::is_same&lt; <span class="keyword">typename</span> f_tr::template decay_arg&lt;0&gt;::type, <span class="keyword">typename</span> f_tr::template decay_arg&lt;1&gt;::type&gt;::value,
<a name="l00049"></a>00049       <span class="stringliteral">&quot;det_manip : the two arguments must of the function must have the same type&quot;</span>);
<a name="l00050"></a>00050    <span class="keyword">public</span>:
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="keyword">typedef</span> <span class="keyword">typename</span> f_tr::template decay_arg&lt;0&gt;::type xy_type;
<a name="l00053"></a>00053     <span class="keyword">typedef</span> <span class="keyword">typename</span> f_tr::result_type                 value_type;
<a name="l00054"></a>00054     static_assert( std::is_floating_point&lt;value_type&gt;::value || triqs::is_complex&lt;value_type&gt;::value, <span class="stringliteral">&quot;det_manip : the function must return a floating number or a complex number&quot;</span>);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     <span class="keyword">typedef</span> arrays::vector&lt;value_type&gt;                 vector_type;
<a name="l00057"></a>00057     <span class="keyword">typedef</span> arrays::matrix&lt;value_type&gt;                 matrix_type;
<a name="l00058"></a>00058     <span class="keyword">typedef</span> arrays::matrix_view&lt;value_type&gt;            matrix_view_type;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060    <span class="keyword">protected</span>: <span class="comment">// the data</span>
<a name="l00061"></a>00061     <span class="keyword">typedef</span> std::ptrdiff_t int_type;
<a name="l00062"></a>00062     <span class="keyword">typedef</span> arrays::range range;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064     FunctionType f;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066     <span class="comment">// serialized data. There are all VALUES.</span>
<a name="l00067"></a>00067     value_type det;
<a name="l00068"></a>00068     <span class="keywordtype">size_t</span> Nmax,N, last_try;
<a name="l00069"></a>00069     std::vector&lt;size_t&gt; row_num,col_num;
<a name="l00070"></a>00070     std::vector&lt;xy_type&gt; x_values,y_values;
<a name="l00071"></a>00071     <span class="keywordtype">int</span> sign;
<a name="l00072"></a>00072     matrix_type mat_inv;
<a name="l00073"></a>00073     <span class="keywordtype">long</span> <span class="keywordtype">long</span> n_opts, n_opts_max_before_check;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075    <span class="keyword">private</span>:
<a name="l00076"></a>00076     <span class="comment">//  ------------     BOOST Serialization ------------</span>
<a name="l00077"></a>00077     <span class="comment">//  What about f ? Not serialized at the moment.</span>
<a name="l00078"></a>00078     <span class="keyword">friend</span> <span class="keyword">class </span>boost::serialization::access;
<a name="l00079"></a>00079     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Archive&gt;
<a name="l00080"></a>00080      <span class="keywordtype">void</span> serialize(Archive &amp; ar) {
<a name="l00081"></a>00081       ar &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;Nmax&quot;</span>,Nmax) &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;N&quot;</span>,N) 
<a name="l00082"></a>00082        &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;n_opts&quot;</span>,n_opts) &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;n_opts_max_before_check&quot;</span>,n_opts_max_before_check) 
<a name="l00083"></a>00083        &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;det&quot;</span>,det) &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;sign&quot;</span>,sign) 
<a name="l00084"></a>00084        &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;Minv&quot;</span>,mat_inv) 
<a name="l00085"></a>00085        &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;row_num&quot;</span>,row_num) &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;col_num&quot;</span>,col_num) 
<a name="l00086"></a>00086        &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;x_values&quot;</span>,x_values) &amp; TRIQS_MAKE_NVP(<span class="stringliteral">&quot;y_values&quot;</span>,y_values); 
<a name="l00087"></a>00087      }
<a name="l00088"></a>00088 
<a name="l00090"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660">00090</a>     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a> (<a class="code" href="classtriqs_1_1h5_1_1group.html" title="A local derivative of Group. Rational : use ADL for h5_read/h5_write, catch and rethrow exception...">h5::group</a> fg, std::string subgroup_name, <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html" title="Standard matrix/det manipulations used in several QMC.">det_manip</a> <span class="keyword">const</span> &amp; g) {
<a name="l00091"></a>00091      <span class="keyword">auto</span> gr =  fg.<a class="code" href="classtriqs_1_1h5_1_1group.html#ac3e898d9eeba69545ab9a0bf73e114b8" title="Create a subgroup.">create_group</a>(subgroup_name);
<a name="l00092"></a>00092      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;N&quot;</span>,g.N);
<a name="l00093"></a>00093      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;mat_inv&quot;</span>,g.mat_inv);
<a name="l00094"></a>00094      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;det&quot;</span>,g.det);
<a name="l00095"></a>00095      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;sign&quot;</span>,g.sign);
<a name="l00096"></a>00096      <span class="comment">//h5_write(gr,&quot;row_num&quot;,g.row_num);</span>
<a name="l00097"></a>00097      <span class="comment">//h5_write(gr,&quot;col_num&quot;,g.col_num);</span>
<a name="l00098"></a>00098      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;x_values&quot;</span>,g.x_values);
<a name="l00099"></a>00099      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;y_values&quot;</span>,g.y_values);
<a name="l00100"></a>00100      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;n_opts&quot;</span>,g.n_opts);
<a name="l00101"></a>00101      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a16c881ef84c773b26cc1c4ec0c2a8660" title="Write into HDF5.">h5_write</a>(gr,<span class="stringliteral">&quot;n_opts_max_before_check&quot;</span>,g.n_opts_max_before_check);
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103 
<a name="l00105"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10">00105</a>     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>  (<a class="code" href="classtriqs_1_1h5_1_1group.html" title="A local derivative of Group. Rational : use ADL for h5_read/h5_write, catch and rethrow exception...">h5::group</a> fg, std::string subgroup_name, <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html" title="Standard matrix/det manipulations used in several QMC.">det_manip</a> &amp; g){
<a name="l00106"></a>00106      <span class="keyword">auto</span> gr = fg.<a class="code" href="classtriqs_1_1h5_1_1group.html#a984aa3fa6adf34c3e8140d907b4dd7ad" title="Open a subgroup. Throw it if does not exists.">open_group</a>(subgroup_name);
<a name="l00107"></a>00107      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;N&quot;</span>,g.N);
<a name="l00108"></a>00108      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;mat_inv&quot;</span>,g.mat_inv);
<a name="l00109"></a>00109      g.Nmax = first_dim(g.mat_inv); <span class="comment">// restore Nmax</span>
<a name="l00110"></a>00110      g.last_try = 0; 
<a name="l00111"></a>00111      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;det&quot;</span>,g.det);
<a name="l00112"></a>00112      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;sign&quot;</span>,g.sign);
<a name="l00113"></a>00113      <span class="comment">//h5_read(gr,&quot;row_num&quot;,g.row_num);</span>
<a name="l00114"></a>00114      <span class="comment">//h5_read(gr,&quot;col_num&quot;,g.col_num);</span>
<a name="l00115"></a>00115      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;x_values&quot;</span>,g.x_values);
<a name="l00116"></a>00116      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;y_values&quot;</span>,g.y_values);
<a name="l00117"></a>00117      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;n_opts&quot;</span>,g.n_opts);
<a name="l00118"></a>00118      <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3efcc4ba0deae8f7be6e6a4f8ddc1d10" title="Read from HDF5.">h5_read</a>(gr,<span class="stringliteral">&quot;n_opts_max_before_check&quot;</span>,g.n_opts_max_before_check);
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121    <span class="keyword">private</span>:
<a name="l00122"></a>00122     <span class="comment">// temporary work data, not saved, serialized, etc....  </span>
<a name="l00123"></a>00123     <span class="keyword">struct </span>work_data_type1 { 
<a name="l00124"></a>00124      xy_type x, y;
<a name="l00125"></a>00125      vector_type MB,MC, B, C;
<a name="l00126"></a>00126      value_type ksi;
<a name="l00127"></a>00127      <span class="keywordtype">size_t</span> i,j,ireal,jreal;
<a name="l00128"></a>00128      <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(<span class="keywordtype">size_t</span> s) { B.resize(s); C.resize(s); MB.resize(s); MC.resize(s); MB()=0; MC()=0; }
<a name="l00129"></a>00129     };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keyword">struct </span>work_data_type2 { 
<a name="l00132"></a>00132      xy_type x[2], y[2];
<a name="l00133"></a>00133      matrix_type MB,MC, B, C,ksi;
<a name="l00134"></a>00134      <span class="keywordtype">size_t</span> i[2],j[2],ireal[2],jreal[2];
<a name="l00135"></a>00135      <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(<span class="keywordtype">size_t</span> s) { MB.resize(s,2); MC.resize(2,s); B.resize(s,2), C.resize(2,s); ksi.resize(2,2); MB() = 0; MC() = 0; }
<a name="l00136"></a>00136      value_type det_ksi()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ksi(0,0) * ksi(1,1) - ksi(1,0)* ksi(0,1);}
<a name="l00137"></a>00137     };
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     work_data_type1 w1;
<a name="l00140"></a>00140     work_data_type2 w2;
<a name="l00141"></a>00141     value_type newdet;
<a name="l00142"></a>00142     <span class="keywordtype">int</span> newsign;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144    <span class="keyword">private</span>: <span class="comment">// for the move constructor, I need to separate the swap since f may not be defaulted constructed</span>
<a name="l00145"></a>00145     <span class="keywordtype">void</span> swap_but_f (<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a> &amp; rhs) noexcept { 
<a name="l00146"></a>00146      <span class="keyword">using</span> std::swap;
<a name="l00147"></a>00147 <span class="preprocessor">#define SW(a) swap(this-&gt;a,rhs.a)</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>     SW(det);SW(Nmax);SW(N); SW(last_try);
<a name="l00149"></a>00149      SW(row_num); SW(col_num);
<a name="l00150"></a>00150      SW(x_values); SW(y_values);
<a name="l00151"></a>00151      SW(sign); SW(mat_inv); SW(n_opts); SW(n_opts_max_before_check);
<a name="l00152"></a>00152      SW(w1); SW(w2); SW(newdet); SW(newsign);
<a name="l00153"></a>00153 <span class="preprocessor">#undef SW</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span>    }
<a name="l00155"></a>00155     
<a name="l00156"></a>00156     <span class="keyword">friend</span> <span class="keywordtype">void</span> swap(<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a>&amp; lhs, <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a> &amp; rhs) noexcept { 
<a name="l00157"></a>00157      <span class="keyword">using</span> std::swap;
<a name="l00158"></a>00158      swap(lhs.f, rhs.f); 
<a name="l00159"></a>00159      lhs.swap_but_f(rhs);
<a name="l00160"></a>00160     }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162    <span class="keyword">public</span>:
<a name="l00163"></a>00163 
<a name="l00169"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">00169</a>     <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a> (<span class="keywordtype">size_t</span> new_size) { 
<a name="l00170"></a>00170      <span class="keywordflow">if</span> (new_size &lt;= Nmax) <span class="keywordflow">return</span>;
<a name="l00171"></a>00171      matrix_type Mcopy(mat_inv);
<a name="l00172"></a>00172      <span class="keywordtype">size_t</span> N0 = Nmax; Nmax = new_size;
<a name="l00173"></a>00173      mat_inv.resize(Nmax,Nmax); mat_inv(range(0,N0), range(0,N0)) = Mcopy; <span class="comment">// keep the content of mat_inv ---&gt; into the lib ?</span>
<a name="l00174"></a>00174      row_num.reserve(Nmax);col_num.reserve(Nmax); x_values.reserve(Nmax);y_values.reserve(Nmax);
<a name="l00175"></a>00175      w1.reserve(Nmax); w2.reserve(Nmax);
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178    <span class="keyword">private</span>:
<a name="l00179"></a>00179     <span class="keywordtype">void</span> _construct_common() { 
<a name="l00180"></a>00180      last_try=0; sign =1;
<a name="l00181"></a>00181      n_opts=0; n_opts_max_before_check = 100;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184    <span class="keyword">public</span>:
<a name="l00193"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7">00193</a>     <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a>(FunctionType F,<span class="keywordtype">size_t</span> init_size):
<a name="l00194"></a>00194      f(std::move(F)), Nmax(0) , N(0){ 
<a name="l00195"></a>00195       <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(init_size);
<a name="l00196"></a>00196       mat_inv()=0;
<a name="l00197"></a>00197       det = 1; 
<a name="l00198"></a>00198       _construct_common();
<a name="l00199"></a>00199      }
<a name="l00200"></a>00200 
<a name="l00207"></a>00207     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ArgumentContainer1, <span class="keyword">typename</span> ArgumentContainer2&gt;
<a name="l00208"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ae0b8efbd745f0d59366523dc803d24b6">00208</a>     <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ae0b8efbd745f0d59366523dc803d24b6" title="Constructor.">det_manip</a>(FunctionType F, ArgumentContainer1 <span class="keyword">const</span> &amp; X, ArgumentContainer2 <span class="keyword">const</span> &amp; Y) : f(std::move(F)), Nmax(0) { 
<a name="l00209"></a>00209       <span class="keywordflow">if</span> (X.size() != Y.size()) TRIQS_RUNTIME_ERROR&lt;&lt; <span class="stringliteral">&quot; X.size != Y.size&quot;</span>;
<a name="l00210"></a>00210       _construct_common();
<a name="l00211"></a>00211       N =X.size(); 
<a name="l00212"></a>00212       <span class="keywordflow">if</span> (N==0) { det = 1; <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(30); <span class="keywordflow">return</span>;} 
<a name="l00213"></a>00213       <span class="keywordflow">if</span> (N&gt;Nmax) <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(2*N); <span class="comment">// put some margin..</span>
<a name="l00214"></a>00214       std::copy(X.begin(),X.end(), std::back_inserter(x_values));
<a name="l00215"></a>00215       std::copy(Y.begin(),Y.end(), std::back_inserter(y_values));
<a name="l00216"></a>00216       mat_inv()=0;
<a name="l00217"></a>00217       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;N; ++i) { 
<a name="l00218"></a>00218        row_num.push_back(i);col_num.push_back(i); 
<a name="l00219"></a>00219        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;N; ++j)
<a name="l00220"></a>00220         mat_inv(i,j) = f(x_values[i],y_values[j]);
<a name="l00221"></a>00221       }
<a name="l00222"></a>00222       range R(0,N);
<a name="l00223"></a>00223       det = <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3359dad97a164cc249a35098c953ed02">arrays::determinant</a>(mat_inv(R,R));
<a name="l00224"></a>00224       mat_inv(R,R) = inverse(mat_inv(R,R));
<a name="l00225"></a>00225      }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a> (<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html" title="Standard matrix/det manipulations used in several QMC.">det_manip</a> <span class="keyword">const</span>&amp;) = <span class="keywordflow">default</span>;
<a name="l00228"></a>00228     <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a> (<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html" title="Standard matrix/det manipulations used in several QMC.">det_manip</a> &amp;&amp; rhs) noexcept : f(std::move(rhs.f)) { this-&gt;swap_but_f(rhs);} <span class="comment">// f need not have a default constructor and we dont swap the temp data...</span>
<a name="l00229"></a>00229     <span class="comment">//det_manip&amp; operator=(const det_manip&amp;) = default;</span>
<a name="l00230"></a>00230     <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a>&amp;) = <span class="keyword">delete</span>;
<a name="l00231"></a>00231     <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a>&amp; operator=(<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ad6eb02f7010f1a6b506761988bb552a7" title="Constructor.">det_manip</a>&amp;&amp; rhs) noexcept { assert((last_try==0)&amp;&amp;(rhs.last_try==0)); swap(*<span class="keyword">this</span>,rhs); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00232"></a>00232 
<a name="l00234"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aca4e9d5122953f5a779805fd6b894d5a">00234</a>     <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aca4e9d5122953f5a779805fd6b894d5a" title="Put to size 0 : like a vector.">clear</a> () { 
<a name="l00235"></a>00235      N = 0; sign = 1;det =1; last_try = 0;
<a name="l00236"></a>00236      row_num.clear(); col_num.clear(); x_values.clear(); y_values.clear(); 
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="comment">//----------------------- READ ACCESS TO DATA ----------------------------------</span>
<a name="l00240"></a>00240 
<a name="l00242"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aab6ba05cad9c7b2ae0ae7fbd8c71b5bc">00242</a>     <span class="keywordtype">size_t</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aab6ba05cad9c7b2ae0ae7fbd8c71b5bc" title="Current size of the matrix.">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> N;}
<a name="l00243"></a>00243 
<a name="l00245"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#af9a29133d45951698b9d4a0ca74cda8d">00245</a>     xy_type <span class="keyword">const</span> &amp; <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#af9a29133d45951698b9d4a0ca74cda8d" title="Returns the i-th values of x.">get_x</a>(<span class="keywordtype">size_t</span> i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x_values[row_num[i]];}
<a name="l00246"></a>00246 
<a name="l00248"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a0dcf3d3ceee575581fdaed96bbb15ace">00248</a>     xy_type <span class="keyword">const</span> &amp; <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a0dcf3d3ceee575581fdaed96bbb15ace" title="Returns the j-th values of y.">get_y</a>(<span class="keywordtype">size_t</span> j)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> y_values[col_num[j]];}
<a name="l00249"></a>00249 
<a name="l00251"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3359dad97a164cc249a35098c953ed02">00251</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a3359dad97a164cc249a35098c953ed02">determinant</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> sign*det;}
<a name="l00252"></a>00252 
<a name="l00254"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a98f0e2f83414cae9bdfe5054e4a65a84">00254</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a98f0e2f83414cae9bdfe5054e4a65a84">inverse_matrix</a>(<span class="keywordtype">size_t</span> i,<span class="keywordtype">size_t</span> j)<span class="keyword"> const </span>{<span class="keywordflow">return</span> mat_inv(col_num[i],row_num[j]);} <span class="comment">// warning : need to invert the 2 permutations.</span>
<a name="l00255"></a>00255 
<a name="l00257"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aa419f8a6b095a8794005fbdd28100425">00257</a>     matrix_view_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aa419f8a6b095a8794005fbdd28100425" title="Returns the inverse matrix. Warning : this is slow, since it create a new copy, and reorder the lines...">inverse_matrix</a>()<span class="keyword"> const </span>{
<a name="l00258"></a>00258      matrix_type res(N,N);
<a name="l00259"></a>00259      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;N;i++)
<a name="l00260"></a>00260       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;N;j++)
<a name="l00261"></a>00261        res(i,j) = <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aa419f8a6b095a8794005fbdd28100425" title="Returns the inverse matrix. Warning : this is slow, since it create a new copy, and reorder the lines...">inverse_matrix</a>(i,j);
<a name="l00262"></a>00262      <span class="keywordflow">return</span> res;
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264 
<a name="l00266"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5d8849b7a5d70d483d88729c9da6ea2b">00266</a>     matrix_view_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5d8849b7a5d70d483d88729c9da6ea2b" title="Rebuild the matrix. Warning : this is slow, since it create a new matrix and re-evaluate the function...">matrix</a>()<span class="keyword"> const </span>{
<a name="l00267"></a>00267      matrix_type res(N,N);
<a name="l00268"></a>00268      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;N;i++)
<a name="l00269"></a>00269       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;N;j++)
<a name="l00270"></a>00270        res(i,j) = f(<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#af9a29133d45951698b9d4a0ca74cda8d" title="Returns the i-th values of x.">get_x</a>(i), <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a0dcf3d3ceee575581fdaed96bbb15ace" title="Returns the j-th values of y.">get_y</a>(j));
<a name="l00271"></a>00271      <span class="keywordflow">return</span> res;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     <span class="comment">// Given a lambda f : x,y,M, it calls f(x_i,y_j,M_ji) for all i,j</span>
<a name="l00275"></a>00275     <span class="comment">// Order of iteration is NOT fixed, it is optimised (for memory traversal)</span>
<a name="l00276"></a>00276     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LambdaType&gt;
<a name="l00277"></a>00277     <span class="keyword">friend</span> <span class="keywordtype">void</span> <span class="keywordflow">foreach</span>(<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html" title="Standard matrix/det manipulations used in several QMC.">det_manip</a> <span class="keyword">const</span> &amp; d, LambdaType <span class="keyword">const</span> &amp; f) {
<a name="l00278"></a>00278      <span class="comment">//for (size_t i=0; i&lt;d.N;i++)</span>
<a name="l00279"></a>00279       <span class="comment">//for (size_t j=0; j&lt;d.N;j++)</span>
<a name="l00280"></a>00280       <span class="comment">// f(d.x_values[i], d.y_values[j], d.mat_inv(j,i));</span>
<a name="l00281"></a>00281      range R(0,d.N);
<a name="l00282"></a>00282      <span class="keywordflow">foreach</span>(d.mat_inv(R,R), [&amp;f,&amp;d](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> f(d.x_values[i], d.y_values[j], d.mat_inv(j,i));});
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="comment">// ------------------------- OPERATIONS -----------------------------------------------</span>
<a name="l00286"></a>00286 
<a name="l00305"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5cc38d08dc598f38eccac01b0d65f0d4">00305</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5cc38d08dc598f38eccac01b0d65f0d4">try_insert</a>(<span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> j, xy_type <span class="keyword">const</span> &amp; x, xy_type <span class="keyword">const</span> &amp; y) {
<a name="l00306"></a>00306 
<a name="l00307"></a>00307      <span class="comment">// check input and store it for complete_operation</span>
<a name="l00308"></a>00308      assert(i&lt;=N);  assert(j&lt;=N); assert(i&gt;=0); assert(j&gt;=0);
<a name="l00309"></a>00309      <span class="keywordflow">if</span> (N==Nmax) <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(2*Nmax);
<a name="l00310"></a>00310      last_try = 1;
<a name="l00311"></a>00311      w1.i=i; w1.j=j; w1.x=x; w1.y = y;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313      <span class="comment">// treat empty matrix separately </span>
<a name="l00314"></a>00314      <span class="keywordflow">if</span> (N==0) { newdet = f(x,y); newsign = 1; <span class="keywordflow">return</span> newdet; }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316      <span class="comment">// I add the row and col and the end. If the move is rejected,</span>
<a name="l00317"></a>00317      <span class="comment">// no effect since N will not be changed : Minv(i,j) for i,j&gt;=N has no meaning.</span>
<a name="l00318"></a>00318      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k= 0; k&lt; N; k++) {
<a name="l00319"></a>00319       w1.B(k) = f(x_values[k],y);
<a name="l00320"></a>00320       w1.C(k) = f(x, y_values[k]);
<a name="l00321"></a>00321      }
<a name="l00322"></a>00322      range R(0,N);
<a name="l00323"></a>00323      <span class="comment">//w1.MB(R) = mat_inv(R,R) * w1.B(R);// OPTIMIZE BELOW</span>
<a name="l00324"></a>00324      blas::gemv(1.0, mat_inv(R,R), w1.B(R),0.0,w1.MB(R));
<a name="l00325"></a>00325      w1.ksi = f(x,y) - arrays::dot( w1.C(R) , w1.MB(R) );
<a name="l00326"></a>00326      newdet = det*w1.ksi;
<a name="l00327"></a>00327      newsign = ((i + j)%2==0 ? sign : -sign);   <span class="comment">// since N-i0 + N-j0  = i0+j0 [2]</span>
<a name="l00328"></a>00328      <span class="keywordflow">return</span> w1.ksi*(newsign*sign);              <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00329"></a>00329     } 
<a name="l00330"></a>00330     
<a name="l00331"></a>00331     <span class="comment">//fx gives the new line coefficients, fy gives the new column coefficients and ksi is the last coeff (at the intersection of the line and the column). </span>
<a name="l00332"></a>00332     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fx, <span class="keyword">typename</span> Fy&gt;
<a name="l00333"></a>00333     value_type try_insert_from_function(<span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> j, Fx fx, Fy fy, value_type <span class="keyword">const</span> ksi) {
<a name="l00334"></a>00334      
<a name="l00335"></a>00335      <span class="comment">// check input and store it for complete_operation</span>
<a name="l00336"></a>00336      assert(i&lt;=N);  assert(j&lt;=N); assert(i&gt;=0); assert(j&gt;=0);
<a name="l00337"></a>00337      <span class="keywordflow">if</span> (N==Nmax) <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(2*Nmax);
<a name="l00338"></a>00338      last_try = 1;
<a name="l00339"></a>00339      w1.i=i; w1.j=j;
<a name="l00340"></a>00340      
<a name="l00341"></a>00341      <span class="comment">// treat empty matrix separately </span>
<a name="l00342"></a>00342      <span class="keywordflow">if</span> (N==0) { newdet = ksi; newsign = 1; <span class="keywordflow">return</span> newdet; }
<a name="l00343"></a>00343      
<a name="l00344"></a>00344      <span class="comment">// I add the row and col and the end. If the move is rejected,</span>
<a name="l00345"></a>00345      <span class="comment">// no effect since N will not be changed : Minv(i,j) for i,j&gt;=N has no meaning.</span>
<a name="l00346"></a>00346      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k= 0; k&lt; N; k++) {
<a name="l00347"></a>00347       w1.B(k) = fx(x_values[k]);
<a name="l00348"></a>00348       w1.C(k) = fy(y_values[k]);
<a name="l00349"></a>00349      }
<a name="l00350"></a>00350      range R(0,N);
<a name="l00351"></a>00351      <span class="comment">//w1.MB(R) = mat_inv(R,R) * w1.B(R);// OPTIMIZE BELOW</span>
<a name="l00352"></a>00352      blas::gemv(1.0, mat_inv(R,R), w1.B(R),0.0,w1.MB(R));
<a name="l00353"></a>00353      w1.ksi = ksi - arrays::dot( w1.C(R) , w1.MB(R) );
<a name="l00354"></a>00354      newdet = det*w1.ksi;
<a name="l00355"></a>00355      newsign = ((i + j)%2==0 ? sign : -sign);   <span class="comment">// since N-i0 + N-j0  = i0+j0 [2]</span>
<a name="l00356"></a>00356      <span class="keywordflow">return</span> w1.ksi*(newsign*sign);          <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00357"></a>00357     } 
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00360"></a>00360    <span class="keyword">private</span> : 
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="keywordtype">void</span> complete_insert () {
<a name="l00363"></a>00363      <span class="comment">// store the new value of x,y. They are seen through the same permutations as rows and cols resp.</span>
<a name="l00364"></a>00364      x_values.push_back(w1.x); y_values.push_back(w1.y);
<a name="l00365"></a>00365      row_num.push_back(0); col_num.push_back(0);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367      <span class="comment">// special empty case again</span>
<a name="l00368"></a>00368      <span class="keywordflow">if</span> (N==0) { N=1; mat_inv(0,0) = 1/newdet; <span class="keywordflow">return</span>; }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370      range R1(0,N);  
<a name="l00371"></a>00371      <span class="comment">//w1.MC(R1) = mat_inv(R1,R1).transpose() * w1.C(R1); //OPTIMIZE BELOW</span>
<a name="l00372"></a>00372      blas::gemv(1.0, mat_inv(R1,R1).transpose(), w1.C(R1),0.0,w1.MC(R1));
<a name="l00373"></a>00373      w1.MC(N) = -1;
<a name="l00374"></a>00374      w1.MB(N) = -1;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376      N++;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378      <span class="comment">// keep the real position of the row/col</span>
<a name="l00379"></a>00379      <span class="comment">// since we insert a col/row, we have first to push the col at the right</span>
<a name="l00380"></a>00380      <span class="comment">// and then say that col w1.i is stored in N, the last col.</span>
<a name="l00381"></a>00381      <span class="comment">// same for rows</span>
<a name="l00382"></a>00382      <span class="keywordflow">for</span> (int_type i =N-2; i&gt;=int_type(w1.i); i--) row_num[i+1]= row_num[i];
<a name="l00383"></a>00383      row_num[w1.i] = N-1;
<a name="l00384"></a>00384      <span class="keywordflow">for</span> (int_type i =N-2; i&gt;=int_type(w1.j); i--) col_num[i+1]= col_num[i];
<a name="l00385"></a>00385      col_num[w1.j] = N-1;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387      <span class="comment">// Minv is ok, we need to complete </span>
<a name="l00388"></a>00388      w1.ksi = 1/w1.ksi;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390      <span class="comment">// compute the change to the inverse</span>
<a name="l00391"></a>00391      <span class="comment">// M += w1.ksi w1.MB w1.MC with BLAS. first put the 0 </span>
<a name="l00392"></a>00392      range R(0,N);
<a name="l00393"></a>00393      mat_inv(R,N-1) = 0;
<a name="l00394"></a>00394      mat_inv(N-1,R) = 0;
<a name="l00395"></a>00395      <span class="comment">//mat_inv(R,R) += w1.ksi* w1.MB(R) * w1.MC(R)// OPTIMIZE BELOW</span>
<a name="l00396"></a>00396      blas::ger(w1.ksi, w1.MB(R) ,w1.MC(R),mat_inv(R,R));
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399    <span class="keyword">public</span> : 
<a name="l00400"></a>00400     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00401"></a>00401 
<a name="l00415"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ab7012f9c04b2ff31f6ca5f3000e38b86">00415</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#ab7012f9c04b2ff31f6ca5f3000e38b86">try_insert2</a>(<span class="keywordtype">size_t</span> i0, <span class="keywordtype">size_t</span> i1, <span class="keywordtype">size_t</span> j0, <span class="keywordtype">size_t</span> j1, xy_type <span class="keyword">const</span> &amp; x0, xy_type <span class="keyword">const</span> &amp; x1, xy_type <span class="keyword">const</span> &amp; y0, xy_type <span class="keyword">const</span> &amp; y1) {
<a name="l00416"></a>00416      <span class="comment">// check input and store it for complete_operation</span>
<a name="l00417"></a>00417      assert(i0!=i1); assert(j0!=j1);assert(i0&lt;=N);  assert(j0&lt;=N); assert(i0&gt;=0); assert(j0&gt;=0);
<a name="l00418"></a>00418      assert(i1&lt;=N+1);  assert(j1&lt;=N+1); assert(i1&gt;=0); assert(j1&gt;=0);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420      <span class="keywordflow">if</span> (N &gt;= Nmax) <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a2cfc76302bf71a2630e7bbcb13e4549c">reserve</a>(2*Nmax); <span class="comment">// check this resize ... we add 2 lines</span>
<a name="l00421"></a>00421      last_try = 10;
<a name="l00422"></a>00422      w2.i[0]=i0;w2.i[1]=i1; w2.j[0]=j0;w2.j[1]=j1;
<a name="l00423"></a>00423      w2.x[0] = x0;w2.y[0] = y0; w2.x[1] = x1;w2.y[1] = y1;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425      <span class="comment">// w1.ksi = Delta(x_values,y_values) - Cw.MB using BLAS</span>
<a name="l00426"></a>00426      w2.ksi(0,0) = f(x0,y0);
<a name="l00427"></a>00427      w2.ksi(0,1) = f(x0,y1);
<a name="l00428"></a>00428      w2.ksi(1,0) = f(x1,y0);
<a name="l00429"></a>00429      w2.ksi(1,1) = f(x1,y1);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431      <span class="comment">// treat empty matrix separately </span>
<a name="l00432"></a>00432      <span class="keywordflow">if</span> (N==0) {
<a name="l00433"></a>00433       newdet = w2.det_ksi(); 
<a name="l00434"></a>00434       newsign = 1;
<a name="l00435"></a>00435       <span class="keywordflow">return</span> newdet;
<a name="l00436"></a>00436      }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438      <span class="comment">// I add the rows and cols and the end. If the move is rejected,</span>
<a name="l00439"></a>00439      <span class="comment">// no effect since N will not be changed : inv_mat(i,j) for i,j&gt;=N has no meaning.</span>
<a name="l00440"></a>00440      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k= 0; k&lt; N; k++) {
<a name="l00441"></a>00441       w2.B(k,0) = f(x_values[k],y0);
<a name="l00442"></a>00442       w2.B(k,1) = f(x_values[k],y1);
<a name="l00443"></a>00443       w2.C(0,k) = f(x0, y_values[k]);
<a name="l00444"></a>00444       w2.C(1,k) = f(x1, y_values[k]);
<a name="l00445"></a>00445      }
<a name="l00446"></a>00446      range R(0,N), R2(0,2);
<a name="l00447"></a>00447      <span class="comment">//w2.MB(R,R2) = mat_inv(R,R) * w2.B(R,R2); // OPTIMIZE BELOW</span>
<a name="l00448"></a>00448      blas::gemm(1.0, mat_inv(R,R) , w2.B(R,R2),0.0,w2.MB(R,R2));
<a name="l00449"></a>00449      <span class="comment">//w2.ksi -= w2.C (R2, R) * w2.MB(R, R2); // OPTIMIZE BELOW</span>
<a name="l00450"></a>00450      blas::gemm(-1.0, w2.C(R2,R), w2.MB(R, R2),1.0,w2.ksi);
<a name="l00451"></a>00451      newdet = det * w2.det_ksi();
<a name="l00452"></a>00452      newsign = ((i0 + j0 + i1 + j1)%2==0 ? sign : -sign); <span class="comment">// since N-i0 + N-j0 + N + 1 -i1 + N+1 -j1 = i0+j0 [2]</span>
<a name="l00453"></a>00453      <span class="keywordflow">return</span> (newdet/det)*(newsign*sign); <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00454"></a>00454     } 
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00457"></a>00457    <span class="keyword">private</span>:
<a name="l00458"></a>00458     <span class="keywordtype">void</span> complete_insert2 () {
<a name="l00459"></a>00459      <span class="comment">// store the new value of x,y. They are seen through the same permutations as rows and cols resp.</span>
<a name="l00460"></a>00460      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;2; ++k) { 
<a name="l00461"></a>00461       x_values.push_back(w2.x[k]); y_values.push_back(w2.y[k]);
<a name="l00462"></a>00462       row_num.push_back(0); col_num.push_back(0);
<a name="l00463"></a>00463      } 
<a name="l00464"></a>00464 
<a name="l00465"></a>00465      range R2(0,2); 
<a name="l00466"></a>00466      <span class="keywordflow">if</span> (N==0) {N=2; mat_inv(R2,R2)=inverse(w2.ksi); row_num[w2.i[1]]=1; col_num[w2.j[1]]=1; <span class="keywordflow">return</span>;}
<a name="l00467"></a>00467 
<a name="l00468"></a>00468      range Ri(0,N);   
<a name="l00469"></a>00469      <span class="comment">//w2.MC(R2,Ri) = w2.C(R2,Ri) * mat_inv(Ri,Ri);// OPTIMIZE BELOW </span>
<a name="l00470"></a>00470      blas::gemm(1.0, w2.C(R2,Ri), mat_inv(Ri,Ri),0.0,w2.MC(R2,Ri));
<a name="l00471"></a>00471      w2.MC(R2, range(N, N+2) ) = -1; <span class="comment">// identity matrix </span>
<a name="l00472"></a>00472      w2.MB(range(N,N+2), R2 ) = -1; <span class="comment">// identity matrix ! </span>
<a name="l00473"></a>00473 
<a name="l00474"></a>00474      <span class="comment">// keep the real position of the row/col</span>
<a name="l00475"></a>00475      <span class="comment">// since we insert a col/row, we have first to push the col at the right</span>
<a name="l00476"></a>00476      <span class="comment">// and then say that col w2.i[0] is stored in N, the last col.</span>
<a name="l00477"></a>00477      <span class="comment">// same for rows</span>
<a name="l00478"></a>00478      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k =0; k&lt;2; ++k) { 
<a name="l00479"></a>00479       N++;
<a name="l00480"></a>00480       <span class="keywordflow">for</span> (int_type i =N-2; i&gt;=int_type(w2.i[k]); i--) row_num[i+1]= row_num[i];
<a name="l00481"></a>00481       row_num[w2.i[k]] = N-1;
<a name="l00482"></a>00482       <span class="keywordflow">for</span> (int_type i =N-2; i&gt;=int_type(w2.j[k]); i--) col_num[i+1]= col_num[i];
<a name="l00483"></a>00483       col_num[w2.j[k]] = N-1;
<a name="l00484"></a>00484      }
<a name="l00485"></a>00485      w2.ksi = inverse (w2.ksi);
<a name="l00486"></a>00486      range R(0,N);
<a name="l00487"></a>00487      mat_inv(R,range(N-2,N)) = 0;
<a name="l00488"></a>00488      mat_inv(range(N-2,N),R) = 0;
<a name="l00489"></a>00489      <span class="comment">//mat_inv(R,R) += w2.MB(R,R2) * (w2.ksi * w2.MC(R2,R)); // OPTIMIZE BELOW</span>
<a name="l00490"></a>00490      blas::gemm(1.0, w2.MB(R,R2), (w2.ksi * w2.MC(R2,R)),1.0,mat_inv(R,R) );
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493    <span class="keyword">public</span>:
<a name="l00494"></a>00494     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00495"></a>00495 
<a name="l00502"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5383561e56e6cc46b79cfd4b8269aa1b">00502</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5383561e56e6cc46b79cfd4b8269aa1b">try_remove</a>(<span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> j){
<a name="l00503"></a>00503      assert(i&lt;N);  assert(j&lt;N); assert(i&gt;=0); assert(j&gt;=0);
<a name="l00504"></a>00504      w1.i=i;w1.j=j;last_try = 2;
<a name="l00505"></a>00505      w1.jreal = col_num[w1.j];
<a name="l00506"></a>00506      w1.ireal = row_num[w1.i];
<a name="l00507"></a>00507      <span class="comment">// compute the newdet</span>
<a name="l00508"></a>00508      <span class="comment">// first we resolve the w1.ireal,w1.jreal, with the permutation of the Minv, then we pick up what</span>
<a name="l00509"></a>00509      <span class="comment">// will become the &#39;corner&#39; coefficient, if the move is accepted, after the exchange of row and col.</span>
<a name="l00510"></a>00510      w1.ksi = mat_inv(w1.jreal,w1.ireal);
<a name="l00511"></a>00511      newdet = det*w1.ksi;
<a name="l00512"></a>00512      newsign = ((i + j)%2==0 ? sign : -sign);
<a name="l00513"></a>00513      <span class="keywordflow">return</span> (newdet/det)*(newsign*sign); <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00516"></a>00516    <span class="keyword">private</span>:
<a name="l00517"></a>00517     <span class="keywordtype">void</span> complete_remove() {
<a name="l00518"></a>00518      <span class="keywordflow">if</span> (N==1) { <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aca4e9d5122953f5a779805fd6b894d5a" title="Put to size 0 : like a vector.">clear</a>(); <span class="keywordflow">return</span>; }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520      <span class="comment">// repack the matrix inv_mat</span>
<a name="l00521"></a>00521      <span class="comment">// swap the rows w1.ireal and N, w1.jreal and N in inv_mat</span>
<a name="l00522"></a>00522      <span class="comment">// Remember that for M row/col is interchanged by inversion, transposition.</span>
<a name="l00523"></a>00523      {
<a name="l00524"></a>00524       range R(0,N);
<a name="l00525"></a>00525       <span class="keywordflow">if</span> (w1.jreal !=N-1){
<a name="l00526"></a>00526        arrays::deep_swap( mat_inv(w1.jreal,R), mat_inv(N-1,R));
<a name="l00527"></a>00527        y_values[w1.jreal] = y_values[N-1]; 
<a name="l00528"></a>00528       }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530       <span class="keywordflow">if</span> (w1.ireal !=N-1){
<a name="l00531"></a>00531        arrays::deep_swap (mat_inv(R,w1.ireal),  mat_inv(R,N-1));
<a name="l00532"></a>00532        x_values[w1.ireal] = x_values[N-1];
<a name="l00533"></a>00533       }
<a name="l00534"></a>00534      }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536      N--;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538      <span class="comment">// M &lt;- a - d^-1 b c with BLAS</span>
<a name="l00539"></a>00539      w1.ksi = - 1/mat_inv(N,N);
<a name="l00540"></a>00540      range R(0,N);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542      <span class="comment">//mat_inv(R,R) += w1.ksi, * mat_inv(R,N) * mat_inv(N,R);</span>
<a name="l00543"></a>00543      blas::ger(w1.ksi,mat_inv(R,N),mat_inv(N,R), mat_inv(R,R));
<a name="l00544"></a>00544 
<a name="l00545"></a>00545      <span class="comment">// modify the permutations</span>
<a name="l00546"></a>00546      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =w1.i; k&lt;N; k++) {row_num[k]= row_num[k+1];}
<a name="l00547"></a>00547      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =w1.j; k&lt;N; k++) {col_num[k]= col_num[k+1];}
<a name="l00548"></a>00548      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =0; k&lt;N; k++) 
<a name="l00549"></a>00549      {
<a name="l00550"></a>00550       <span class="keywordflow">if</span> (col_num[k]==N) col_num[k]=w1.jreal;
<a name="l00551"></a>00551       <span class="keywordflow">if</span> (row_num[k]==N) row_num[k]=w1.ireal;
<a name="l00552"></a>00552      }
<a name="l00553"></a>00553      row_num.pop_back(); col_num.pop_back();
<a name="l00554"></a>00554      x_values.pop_back(); y_values.pop_back();
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557    <span class="keyword">public</span>:
<a name="l00558"></a>00558     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00559"></a>00559 
<a name="l00566"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5e2d5c0d827c1939c5e324bf2c7809b5">00566</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5e2d5c0d827c1939c5e324bf2c7809b5">try_remove2</a>(<span class="keywordtype">size_t</span> i0, <span class="keywordtype">size_t</span> i1, <span class="keywordtype">size_t</span> j0, <span class="keywordtype">size_t</span> j1) {
<a name="l00567"></a>00567 
<a name="l00568"></a>00568      assert(N&gt;=2); assert(i0!=i1); assert(j0!=j1);
<a name="l00569"></a>00569      assert(i0&lt;N);  assert(j0&lt;N); assert(i0&gt;=0); assert(j0&gt;=0); 
<a name="l00570"></a>00570      assert(i1&lt;N+1);  assert(j1&lt;N+1);assert(i1&gt;=0); assert(j1&gt;=0);  
<a name="l00571"></a>00571 
<a name="l00572"></a>00572      last_try =11;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574      w2.i[0]=std::min(i0,i1); 
<a name="l00575"></a>00575      w2.i[1]=std::max(i0,i1); 
<a name="l00576"></a>00576      w2.j[0]=std::min(j0,j1); 
<a name="l00577"></a>00577      w2.j[1]=std::max(j0,j1); 
<a name="l00578"></a>00578      w2.ireal[0] = row_num[w2.i[0]]; 
<a name="l00579"></a>00579      w2.ireal[1] = row_num[w2.i[1]];
<a name="l00580"></a>00580      w2.jreal[0] = col_num[w2.j[0]]; 
<a name="l00581"></a>00581      w2.jreal[1] = col_num[w2.j[1]];
<a name="l00582"></a>00582 
<a name="l00583"></a>00583      <span class="comment">// compute the newdet</span>
<a name="l00584"></a>00584      w2.ksi(0,0) = mat_inv(w2.jreal[0],w2.ireal[0]);
<a name="l00585"></a>00585      w2.ksi(1,0) = mat_inv(w2.jreal[1],w2.ireal[0]);
<a name="l00586"></a>00586      w2.ksi(0,1) = mat_inv(w2.jreal[0],w2.ireal[1]);
<a name="l00587"></a>00587      w2.ksi(1,1) = mat_inv(w2.jreal[1],w2.ireal[1]);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589      newdet = det * w2.det_ksi();
<a name="l00590"></a>00590      newsign = ((i0 + j0+ i1 + j1)%2==0 ? sign : -sign);
<a name="l00591"></a>00591 
<a name="l00592"></a>00592      <span class="keywordflow">return</span> (newdet/det)*(newsign*sign); <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00595"></a>00595    <span class="keyword">private</span>:
<a name="l00596"></a>00596     <span class="keywordtype">void</span> complete_remove2() {
<a name="l00597"></a>00597      <span class="keywordflow">if</span> (N==2) { <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aca4e9d5122953f5a779805fd6b894d5a" title="Put to size 0 : like a vector.">clear</a>(); <span class="keywordflow">return</span>;} <span class="comment">// put the sign to 1 also .... Change complete_remove... </span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599      <span class="keywordtype">size_t</span> i_real_max =std::max(w2.ireal[0],w2.ireal[1]);  
<a name="l00600"></a>00600      <span class="keywordtype">size_t</span> i_real_min =std::min(w2.ireal[0],w2.ireal[1]);  
<a name="l00601"></a>00601      <span class="keywordtype">size_t</span> j_real_max =std::max(w2.jreal[0],w2.jreal[1]);  
<a name="l00602"></a>00602      <span class="keywordtype">size_t</span> j_real_min =std::min(w2.jreal[0],w2.jreal[1]); 
<a name="l00603"></a>00603 
<a name="l00604"></a>00604      range R(0,N);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606      <span class="keywordflow">if</span> (j_real_max != N-1) { 
<a name="l00607"></a>00607       arrays::deep_swap( mat_inv(j_real_max,R), mat_inv(N-1,R));
<a name="l00608"></a>00608       y_values[ j_real_max ] = y_values[N-1];
<a name="l00609"></a>00609      }
<a name="l00610"></a>00610      <span class="keywordflow">if</span> (j_real_min != N-2) { 
<a name="l00611"></a>00611       arrays::deep_swap( mat_inv(j_real_min,R), mat_inv(N-2,R));
<a name="l00612"></a>00612       y_values[ j_real_min ] = y_values[N-2];
<a name="l00613"></a>00613      }
<a name="l00614"></a>00614      <span class="keywordflow">if</span> (i_real_max != N-1) { 
<a name="l00615"></a>00615       arrays::deep_swap (mat_inv(R,i_real_max),  mat_inv(R,N-1));
<a name="l00616"></a>00616       x_values[ i_real_max ] = x_values[N-1];
<a name="l00617"></a>00617      }
<a name="l00618"></a>00618      <span class="keywordflow">if</span> (i_real_min != N-2) { 
<a name="l00619"></a>00619       arrays::deep_swap (mat_inv(R,i_real_min),  mat_inv(R,N-2));
<a name="l00620"></a>00620       x_values[ i_real_min ] = x_values[N-2];
<a name="l00621"></a>00621      }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623      N -= 2;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625      <span class="comment">// M &lt;- a - d^-1 b c with BLAS</span>
<a name="l00626"></a>00626      range Rn(0,N), Rl(N,N+2);
<a name="l00627"></a>00627      <span class="comment">//w2.ksi = mat_inv(Rl,Rl);</span>
<a name="l00628"></a>00628      <span class="comment">//w2.ksi = inverse( w2.ksi);</span>
<a name="l00629"></a>00629      w2.ksi =  inverse( mat_inv(Rl,Rl));
<a name="l00630"></a>00630 
<a name="l00631"></a>00631      <span class="comment">// write explicitely the second product on ksi for speed ?</span>
<a name="l00632"></a>00632      <span class="comment">//mat_inv(Rn,Rn) -= mat_inv(Rn,Rl) * (w2.ksi * mat_inv(Rl,Rn)); // OPTIMIZE BELOW</span>
<a name="l00633"></a>00633      blas::gemm(-1.0, mat_inv(Rn,Rl), w2.ksi * mat_inv(Rl,Rn),1.0,  mat_inv(Rn,Rn) );
<a name="l00634"></a>00634 
<a name="l00635"></a>00635      <span class="comment">// modify the permutations</span>
<a name="l00636"></a>00636      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =w2.i[0]; k&lt;w2.i[1]-1; k++)   row_num[k] = row_num[k+1];
<a name="l00637"></a>00637      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =w2.i[1]-1; k&lt;N; k++)         row_num[k] = row_num[k+2];
<a name="l00638"></a>00638      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =w2.j[0]; k&lt;w2.j[1]-1; k++)   col_num[k] = col_num[k+1];
<a name="l00639"></a>00639      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =w2.j[1]-1; k&lt;N; k++)         col_num[k] = col_num[k+2];
<a name="l00640"></a>00640      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k =0; k&lt;N; k++) {
<a name="l00641"></a>00641       <span class="keywordflow">if</span> (col_num[k]==N+1)   col_num[k]=j_real_max;
<a name="l00642"></a>00642       <span class="keywordflow">if</span> (col_num[k]==N)     col_num[k]=j_real_min;
<a name="l00643"></a>00643       <span class="keywordflow">if</span> (row_num[k]==N+1)   row_num[k]=i_real_max;
<a name="l00644"></a>00644       <span class="keywordflow">if</span> (row_num[k]==N)     row_num[k]=i_real_min;
<a name="l00645"></a>00645      }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u=0; u&lt;2; ++u) { row_num.pop_back(); col_num.pop_back(); x_values.pop_back(); y_values.pop_back(); } 
<a name="l00648"></a>00648     }
<a name="l00649"></a>00649     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00650"></a>00650    <span class="keyword">public</span>:
<a name="l00651"></a>00651 
<a name="l00658"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a904f145c8821ed3b277e36ffd1dd8406">00658</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a904f145c8821ed3b277e36ffd1dd8406">try_change_col</a>(<span class="keywordtype">size_t</span> j, xy_type <span class="keyword">const</span> &amp; y) {
<a name="l00659"></a>00659      assert(j&lt;N); assert(j&gt;=0);
<a name="l00660"></a>00660      w1.j=j;last_try = 3;
<a name="l00661"></a>00661      w1.jreal = col_num[j];
<a name="l00662"></a>00662      w1.y = y;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664      <span class="comment">// Compute the col B.</span>
<a name="l00665"></a>00665      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i= 0; i&lt;N;i++) w1.MC(i) = f(x_values[i] , w1.y) - f(x_values[i], y_values[w1.jreal]);
<a name="l00666"></a>00666      range R(0,N);
<a name="l00667"></a>00667      <span class="comment">//w1.MB(R) = mat_inv(R,R) * w1.MC(R);// OPTIMIZE BELOW</span>
<a name="l00668"></a>00668      blas::gemv(1.0, mat_inv(R,R), w1.MC(R) ,0.0,  w1.MB(R) );
<a name="l00669"></a>00669 
<a name="l00670"></a>00670      <span class="comment">// compute the newdet</span>
<a name="l00671"></a>00671      w1.ksi = (1+w1.MB(w1.jreal));
<a name="l00672"></a>00672      newdet = det*w1.ksi;
<a name="l00673"></a>00673      newsign = sign;
<a name="l00674"></a>00674      <span class="keywordflow">return</span> (newdet/det)*(newsign*sign); <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00675"></a>00675     }
<a name="l00676"></a>00676     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00677"></a>00677    <span class="keyword">private</span>:
<a name="l00678"></a>00678     <span class="keywordtype">void</span> complete_change_col() {
<a name="l00679"></a>00679      range R(0,N);
<a name="l00680"></a>00680      y_values[w1.jreal] = w1.y;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682      <span class="comment">// modifying M : Mij += w1.ksi Bi Mnj </span>
<a name="l00683"></a>00683      <span class="comment">// using Shermann Morrison formula.</span>
<a name="l00684"></a>00684      <span class="comment">// implemented in 2 times : first Bn=0 so that Mnj is not modified ! and then change Mnj</span>
<a name="l00685"></a>00685      <span class="comment">// Cf notes : simply multiply by -w1.ksi</span>
<a name="l00686"></a>00686      w1.ksi = - 1/(1+ w1.MB(w1.jreal));
<a name="l00687"></a>00687      w1.MB(w1.jreal) = 0;
<a name="l00688"></a>00688      <span class="comment">//mat_inv(R,R) += w1.ksi * w1.MB(R) * mat_inv(w1.jreal,R)); // OPTIMIZE BELOW</span>
<a name="l00689"></a>00689      blas::ger(w1.ksi,w1.MB(R), mat_inv(w1.jreal,R), mat_inv(R,R));
<a name="l00690"></a>00690      mat_inv(w1.jreal,R)*= -w1.ksi; 
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00694"></a>00694    <span class="keyword">public</span>:
<a name="l00695"></a>00695 
<a name="l00702"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a8b68e0d5e6c4ddabc7517afa250f4e67">00702</a>     value_type <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a8b68e0d5e6c4ddabc7517afa250f4e67">try_change_row</a>(<span class="keywordtype">size_t</span> i, xy_type <span class="keyword">const</span> &amp; x) {
<a name="l00703"></a>00703      assert(i&lt;N); assert(i&gt;=0);
<a name="l00704"></a>00704      w1.i=i;last_try = 4;
<a name="l00705"></a>00705      w1.ireal = row_num[i];
<a name="l00706"></a>00706      w1.x = x;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708      <span class="comment">// Compute the col B.</span>
<a name="l00709"></a>00709      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i= 0; i&lt;N;i++) w1.MB(i) = f(w1.x, y_values[i] ) -  f(x_values[w1.ireal], y_values[i] ); 
<a name="l00710"></a>00710      range R(0,N);
<a name="l00711"></a>00711      <span class="comment">//w1.MC(R) = mat_inv(R,R).transpose() * w1.MB(R); // OPTIMIZE BELOW </span>
<a name="l00712"></a>00712      blas::gemv(1.0, mat_inv(R,R).transpose(), w1.MB(R),0.0,  w1.MC(R));
<a name="l00713"></a>00713 
<a name="l00714"></a>00714      <span class="comment">// compute the newdet</span>
<a name="l00715"></a>00715      w1.ksi = (1+w1.MC(w1.ireal));
<a name="l00716"></a>00716      newdet = det*w1.ksi;
<a name="l00717"></a>00717      newsign = sign;
<a name="l00718"></a>00718      <span class="keywordflow">return</span> (newdet/det)*(newsign*sign); <span class="comment">// sign is unity, hence 1/sign == sign</span>
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00721"></a>00721    <span class="keyword">private</span>:
<a name="l00722"></a>00722     <span class="keywordtype">void</span> complete_change_row() {
<a name="l00723"></a>00723      range R(0,N);
<a name="l00724"></a>00724      x_values[w1.ireal] = w1.x;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726      <span class="comment">// modifying M : M ij += w1.ksi Min Cj</span>
<a name="l00727"></a>00727      <span class="comment">// using Shermann Morrison formula.</span>
<a name="l00728"></a>00728      <span class="comment">// impl. Cf case 3</span>
<a name="l00729"></a>00729      w1.ksi = - 1/(1+ w1.MC(w1.ireal));
<a name="l00730"></a>00730      w1.MC(w1.ireal) = 0;
<a name="l00731"></a>00731      <span class="comment">//mat_inv(R,R) += w1.ksi * mat_inv(R,w1.ireal) * w1.MC(R);</span>
<a name="l00732"></a>00732      blas::ger(w1.ksi,mat_inv(R,w1.ireal),w1.MC(R),  mat_inv(R,R));
<a name="l00733"></a>00733      mat_inv(R,w1.ireal) *= -w1.ksi; 
<a name="l00734"></a>00734     }
<a name="l00735"></a>00735     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00736"></a>00736    <span class="keyword">private</span>: 
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <span class="keywordtype">void</span> check_mat_inv (<span class="keywordtype">double</span> precision_warning=1.e-8, <span class="keywordtype">double</span> precision_error=1.e-5) { 
<a name="l00739"></a>00739      <span class="keywordflow">if</span> (N==0) <span class="keywordflow">return</span>;
<a name="l00740"></a>00740      <span class="keyword">const</span> <span class="keywordtype">bool</span> relative = <span class="keyword">true</span>;
<a name="l00741"></a>00741      matrix_type res(N,N);
<a name="l00742"></a>00742      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;N;i++)
<a name="l00743"></a>00743       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;N;j++)
<a name="l00744"></a>00744        res(i,j) = f(x_values[i], y_values[j]);
<a name="l00745"></a>00745      res = inverse(res); 
<a name="l00746"></a>00746      <span class="keywordtype">double</span> r = max_element (abs(res - mat_inv(range(0,N),range(0,N))));
<a name="l00747"></a>00747      <span class="keywordtype">double</span> r2= max_element (abs(res + mat_inv(range(0,N),range(0,N))));
<a name="l00748"></a>00748      <span class="comment">//value_type r = max_element (abs(res - mat_inv(range(0,N),range(0,N))));</span>
<a name="l00749"></a>00749      <span class="comment">//value_type r2= max_element (abs(res + mat_inv(range(0,N),range(0,N))));</span>
<a name="l00750"></a>00750      <span class="comment">//#define TRIQS_DET_MANIP_VERBOSE_CHECK</span>
<a name="l00751"></a>00751 <span class="preprocessor">#ifdef TRIQS_DET_MANIP_VERBOSE_CHECK</span>
<a name="l00752"></a>00752 <span class="preprocessor"></span>     std::cout  &lt;&lt; <span class="stringliteral">&quot;----------------&quot;</span>&lt;&lt;std::endl 
<a name="l00753"></a>00753       &lt;&lt; <span class="stringliteral">&quot;check &quot;</span> &lt;&lt; <span class="stringliteral">&quot;N = &quot;</span>&lt;&lt; N &lt;&lt;<span class="stringliteral">&quot;  &quot;</span> &lt;&lt;<span class="stringliteral">&quot;r,r2 =   &quot;</span>&lt;&lt; r &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>&lt;&lt; r2 &lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt; std::endl;  
<a name="l00754"></a>00754 <span class="preprocessor">#endif</span>
<a name="l00755"></a>00755 <span class="preprocessor"></span>     <span class="keywordtype">bool</span> err =  !( r &lt;  (relative ? precision_error * r2 : precision_error));
<a name="l00756"></a>00756      <span class="keywordtype">bool</span> war =  !( r &lt;  (relative ? precision_warning * r2 : precision_warning));
<a name="l00757"></a>00757      <span class="keywordflow">if</span> (err || war) {
<a name="l00758"></a>00758        std::cerr &lt;&lt; <span class="stringliteral">&quot;matrix  = &quot;</span> &lt;&lt;<a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a5d8849b7a5d70d483d88729c9da6ea2b" title="Rebuild the matrix. Warning : this is slow, since it create a new matrix and re-evaluate the function...">matrix</a>() &lt;&lt;std::endl;
<a name="l00759"></a>00759        std::cerr &lt;&lt; <span class="stringliteral">&quot;inverse_matrix = &quot;</span>&lt;&lt; <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#aa419f8a6b095a8794005fbdd28100425" title="Returns the inverse matrix. Warning : this is slow, since it create a new copy, and reorder the lines...">inverse_matrix</a>()&lt;&lt; std::endl;
<a name="l00760"></a>00760      }
<a name="l00761"></a>00761      <span class="keywordflow">if</span> (war) std::cerr &lt;&lt; <span class="stringliteral">&quot;Warning : det_manip deviation above warning threshold &quot;</span> 
<a name="l00762"></a>00762       &lt;&lt; <span class="stringliteral">&quot;check &quot;</span> &lt;&lt; <span class="stringliteral">&quot;N = &quot;</span>&lt;&lt; N &lt;&lt;<span class="stringliteral">&quot;  &quot;</span> &lt;&lt;<span class="stringliteral">&quot;\n   max(abs(M^-1 - M^-1_true)) = &quot;</span>&lt;&lt; r 
<a name="l00763"></a>00763       &lt;&lt; <span class="stringliteral">&quot;\n   precision*max(abs(M^-1 + M^-1_true)) = &quot;</span>&lt;&lt; (relative ? precision_warning * r2 : precision_warning)&lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt; std::endl;
<a name="l00764"></a>00764      <span class="keywordflow">if</span> (err) TRIQS_RUNTIME_ERROR &lt;&lt; <span class="stringliteral">&quot;Error : det_manip deviation above critical threshold !! &quot;</span> ;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766      <span class="comment">// since we have the proper inverse, replace the matrix </span>
<a name="l00767"></a>00767      mat_inv(range(0,N),range(0,N)) = res;
<a name="l00768"></a>00768     }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     <span class="comment">//------------------------------------------------------------------------------------------</span>
<a name="l00771"></a>00771    <span class="keyword">public</span>:
<a name="l00776"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a0e70f2e4376692d779da86ff1d5bb783">00776</a>     <span class="keywordtype">void</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#a0e70f2e4376692d779da86ff1d5bb783">complete_operation</a>() {
<a name="l00777"></a>00777      <span class="keywordflow">switch</span>(last_try){
<a name="l00778"></a>00778       <span class="keywordflow">case</span>(1):
<a name="l00779"></a>00779        complete_insert();
<a name="l00780"></a>00780        <span class="keywordflow">break</span>;
<a name="l00781"></a>00781       <span class="keywordflow">case</span>(2): 
<a name="l00782"></a>00782        complete_remove();
<a name="l00783"></a>00783        <span class="keywordflow">break</span>;
<a name="l00784"></a>00784       <span class="keywordflow">case</span>(3): 
<a name="l00785"></a>00785        complete_change_col();
<a name="l00786"></a>00786        <span class="keywordflow">break</span>;
<a name="l00787"></a>00787       <span class="keywordflow">case</span>(4): 
<a name="l00788"></a>00788        complete_change_row();
<a name="l00789"></a>00789        <span class="keywordflow">break</span>;
<a name="l00790"></a>00790       <span class="keywordflow">case</span>(10): 
<a name="l00791"></a>00791        complete_insert2();
<a name="l00792"></a>00792        <span class="keywordflow">break</span>;
<a name="l00793"></a>00793       <span class="keywordflow">case</span>(11): 
<a name="l00794"></a>00794        complete_remove2();
<a name="l00795"></a>00795        <span class="keywordflow">break</span>;
<a name="l00796"></a>00796       <span class="keywordflow">case</span>(0):
<a name="l00797"></a>00797        last_try=0; <span class="keywordflow">return</span>; 
<a name="l00798"></a>00798        <span class="keywordflow">break</span>; <span class="comment">// double call of complete_operation... </span>
<a name="l00799"></a>00799       <span class="keywordflow">default</span>: 
<a name="l00800"></a>00800        TRIQS_RUNTIME_ERROR&lt;&lt; <span class="stringliteral">&quot;Misuing det_manip&quot;</span>;
<a name="l00801"></a>00801      }
<a name="l00802"></a>00802      det = newdet;
<a name="l00803"></a>00803      sign = newsign;
<a name="l00804"></a>00804      last_try =0;
<a name="l00805"></a>00805      ++n_opts;
<a name="l00806"></a>00806      <span class="keywordflow">if</span> (n_opts &gt; n_opts_max_before_check) { check_mat_inv(); n_opts=0;}
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808 
<a name="l00810"></a>00810     <span class="keyword">enum</span> RollDirection {None,Up, Down,Left,Right};
<a name="l00811"></a>00811 
<a name="l00824"></a><a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#af2811030b3dc285cd1204d1eb6ddf7e2">00824</a>     <span class="keywordtype">int</span> <a class="code" href="classtriqs_1_1det__manip_1_1det__manip.html#af2811030b3dc285cd1204d1eb6ddf7e2">roll_matrix</a>(RollDirection roll) {
<a name="l00825"></a>00825      <span class="keywordtype">size_t</span> tmp;
<a name="l00826"></a>00826      <span class="keyword">const</span> int_type NN=N;
<a name="l00827"></a>00827      <span class="keywordflow">switch</span> (roll) {
<a name="l00828"></a>00828       <span class="keywordflow">case</span>(None) : 
<a name="l00829"></a>00829        <span class="keywordflow">return</span> 1;
<a name="l00830"></a>00830       <span class="keywordflow">case</span>(Down) : 
<a name="l00831"></a>00831        tmp = row_num[N-1];
<a name="l00832"></a>00832        <span class="keywordflow">for</span> (int_type i =NN-2; i&gt;=0; i--) row_num[i+1]= row_num[i];
<a name="l00833"></a>00833        row_num[0] = tmp;
<a name="l00834"></a>00834        <span class="keywordflow">break</span>;
<a name="l00835"></a>00835       <span class="keywordflow">case</span>(Up) : 
<a name="l00836"></a>00836        tmp = row_num[0];
<a name="l00837"></a>00837        <span class="keywordflow">for</span> (int_type i =0; i&lt;N-1; i++) row_num[i]= row_num[i+1];
<a name="l00838"></a>00838        row_num[N-1] = tmp;
<a name="l00839"></a>00839        <span class="keywordflow">break</span>;
<a name="l00840"></a>00840       <span class="keywordflow">case</span>(Right) : 
<a name="l00841"></a>00841        tmp = col_num[N-1];
<a name="l00842"></a>00842        <span class="keywordflow">for</span> (int_type i =NN-2; i&gt;=0; i--) col_num[i+1]= col_num[i];
<a name="l00843"></a>00843        col_num[0] = tmp;
<a name="l00844"></a>00844        <span class="keywordflow">break</span>;
<a name="l00845"></a>00845       <span class="keywordflow">case</span>(Left): 
<a name="l00846"></a>00846        tmp = col_num[0];
<a name="l00847"></a>00847        <span class="keywordflow">for</span> (int_type i =0; i&lt;N-1; i++) col_num[i]= col_num[i+1];
<a name="l00848"></a>00848        col_num[N-1] = tmp;
<a name="l00849"></a>00849        <span class="keywordflow">break</span>;
<a name="l00850"></a>00850       <span class="keywordflow">default</span>:
<a name="l00851"></a>00851        assert(0);
<a name="l00852"></a>00852      }
<a name="l00853"></a>00853      <span class="comment">// signature of the cycle of order N : (-1)^(N-1)</span>
<a name="l00854"></a>00854      <span class="keywordflow">if</span> ((N-1)%2==1) { sign *=-1; <span class="keywordflow">return</span> -1;}
<a name="l00855"></a>00855      <span class="keywordflow">return</span> 1;
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857   };
<a name="l00858"></a>00858 }}
<a name="l00859"></a>00859 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 23 2014 16:36:56 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
